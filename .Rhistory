#generates pairs of stock prices for variable volatility and
# constant volatility models
#the same random number are used in both models
dt=T/m
S=matrix(S0,nrow=m+1,ncol=n)
B=0
t=seq(0,T,length.out = m+1)
for(i in 1:m){
Xi=rnorm(n,sd=sqrt(dt))
S[i+1,]=S[i,]*(1+mu*dt+sigma(S[i,])*Xi)
B=cbind(B,(B+Xi)) #current value of the Brownian motion
}
ST1 = (S[(floor((T1/T)*m) + 1),] + S[(ceiling((T1/T)*m) + 1),])/2
S_cont=S0*exp((mu-sigma1**2/2)*T+sigma1*B)
BT1 = (B[(floor((T1/T)*m) + 1),] + B[(ceiling((T1/T)*m) + 1),])/2
ST1_cont=S0*exp((mu-sigma1**2/2)*T1+sigma1*BT1)
cbind(ST1,  S[m+1,], ST1_cont, ST_cont)
}
gen_control=function(n){
return(S_euler_control(n,S0,m,T,r-D,sigma,sigma1))
}
gen_control(10)
S_euler_control=function(n,S0,m,T,mu,sigma,sigma1){
#generates pairs of stock prices for variable volatility and
# constant volatility models
#the same random number are used in both models
dt=T/m
S=matrix(S0,nrow=m+1,ncol=n)
B=0
t=seq(0,T,length.out = m+1)
for(i in 1:m){
Xi=rnorm(n,sd=sqrt(dt))
S[i+1,]=S[i,]*(1+mu*dt+sigma(S[i,])*Xi)
B=cbind(B,(B+Xi)) #current value of the Brownian motion
}
ST1 = (S[(floor((T1/T)*m) + 1),] + S[(ceiling((T1/T)*m) + 1),])/2
ST_cont=S0*exp((mu-sigma1**2/2)*T+sigma1*B)
BT1 = (B[(floor((T1/T)*m) + 1),] + B[(ceiling((T1/T)*m) + 1),])/2
ST1_cont=S0*exp((mu-sigma1**2/2)*T1+sigma1*BT1)
cbind(ST1,  S[m+1,], ST1_cont, ST_cont)
}
gen_control=function(n){
return(S_euler_control(n,S0,m,T,r-D,sigma,sigma1))
}
gen_control(10)
#SIMULATION METHODS IN FINANCIAL MATHEMATICS (MTMS.02.038)
#Exam
#Mats Ploompuu
#exercise 1
#standard MC method
#we need 2 stock prices on the same trajectory:
#one in the middle, the other in the end
#B(t) = B(t1) + (B(t) - B(t1)), where B(t1) ~ N(0, sqrt(t1)) and (B(t) - B(t1)) ~ N(0, sqrt(t-t1))
#exact fomula for computing stock prices:
gen = function(n){
BT1 = sqrt(T1)*rnorm(n)
BT = sqrt(T-T1)*rnorm(n)
ST1 = S0*exp((r-D - sigma**2 / 2)*T1 + sigma*BT1)
ST = ST1*exp((r-D - sigma**2 / 2)*(T-T1) + sigma*BT)
cbind(ST1, ST)
}
#option price
g=function(s){
return(exp(-r*0.6)* (pmax(48-s[,2],0)*(s[,1] > 50) + 0*(s[,1] <= 50))   )
}
#to compute answer with given accuracy:
MC2 = function(g, gen, alpha, error){
n0=100
sum_Y=0
sum_Y2=0
n=0
error_estimate=error+1
while(error_estimate>error){
X=gen(n0)
n=n+n0
Y=g(X)
sum_Y=sum_Y+sum(Y)
sum_Y2=sum_Y2+sum(Y**2)
sigma_y=sqrt(abs(sum_Y2-sum_Y**2/n)/(n-1))
error_estimate=-qnorm(alpha/2)*sigma_y/sqrt(n)
}
results = c(sum_Y/n, n)
}
#given parameters:
D = 0
r = 0.03
S0 = 45
T1 = 0.25
T = 0.6
sigma = 0.5
error = 0.01
alpha = 0.05
answer = MC2(g = g, gen = gen, alpha = alpha, error = error)
answer #[1] 7.517297e-01 3.294400e+05
#excercise 2
#derivative of the oprion price with respect to T1
genS_der = function(n){
BT11 = sqrt(T1-h)*rnorm(n)
BT12 = sqrt(2*h)*rnorm(n)
BT = sqrt(T-(T1 + h))*rnorm(n)
ST11 = S0*exp((r-D - sigma**2 / 2)*(T1-h) + sigma*BT11)
ST12 = ST11*exp((r-D - sigma**2 / 2)*2*h + sigma*BT12)
ST = ST12*exp((r-D - sigma**2 / 2)*(T-(T1 + h)) + sigma*BT)
cbind(ST11, ST12, ST)
}
# g=function(s){
#   return(exp(-r*0.6)* (pmax(48-s[,2],0)*(s[,1] > 50) + 0*(s[,1] <= 50))   )
# }
g_der = function(x){
x1 = x[,c(2,3)]
x2 = x[,c(1,3)]
return((g(x1)-g(x2))/(2*h))
}
h=0.05
alpha=0.1
MCerror=0.1
ans_der = MC2(gen=genS_der,g=g_der,alpha=alpha,error=MCerror)
ans_der #[1]     -2.13643 386800.00000
#find h
alpha = 0.1
MC_error = 0.01 #choose smth
rel_error = 0.01
h0 = 0.05 #choose h0
h = h0
result1 = MC2(g = g_der, gen = genS_der, error = MC_error, alpha = alpha)[1]
h = h0/2
result2 = MC2(g = g_der, gen = genS_der, error = MC_error, alpha = alpha)[1]
#is MCerror small enough to see the effect of changing h?
abs(result1 - result2) > 2*MC_error #TRUE
total_error=abs(result2*rel_error)
C=4/(3*h0^2)*(abs(result1-result2)+2*MCerror)
h=sqrt(total_error/(2*C))
h #0.009568505
#use that h to find answer with relative error of 0.01:
MC2_relative=function(g, gen, rel_error, alpha){
n0=1000
sum_Y=0
sum_Y2=0
n=0
error_estimate=rel_error+1
while(error_estimate>rel_error){
X=genX(n0)
n=n+n0
Y=g(X)
sum_Y=sum_Y+sum(Y)
sum_Y2=sum_Y2+sum(Y**2)
sigma_y=sqrt(abs(sum_Y2-sum_Y**2/n)/(n-1))
error_estimate=(-qnorm(alpha/2)*sigma_y/sqrt(n))/(abs(sum_Y/n))
}
return(c(sum_Y/n,n))
}
answ = MC2_relative(g = g_der, gen = genS_der, rel_error = rel_error, alpha = alpha)
answ #-2.226951e+00  6.895700e+07
#exercise 3
#function for sigma
sigma = function(s){
0.4 + 0.2/(1 + 0.1*(s-47)**2)
}
#Euler's method in case of variable volatility.
S_euler2=function(n,S0,m,T,r,D,sigma){
mu = r-D
dt=T/m
S=matrix(S0,nrow=m+1,ncol=n)
t=seq(0,T,length.out = m+1)
for (i in 1:m){
S[i+1,]=S[i,]*(1+mu*dt+sigma(s=S[i,])*sqrt(dt)*rnorm(n))
}
cbind(S[0.5*m+1,],  S[m+1,]) #stock price at the moments T1 and T
}
gen_euler=function(n){
return(S_euler2(n,S0,m,T, r, D, sigma))
}
#test: m = 10, error = 0.01
m = 10; error = 0.01; alpha = 0.05
ansx = MC2(g = g, gen = gen_euler, alpha = alpha, error = error)
ansx #5.996675e-01 2.541000e+05
#compute value of the option with total error of 0.005, alpha = 0.05
total_error = 0.005
#computations to estimate cbar
m0 = 5
epsilon0=0.01
m=m0
Vm0e0=MC2(g = g, gen = gen_euler ,epsilon0,alpha)[1]
m=2*m0
V2m0e0=MC2(g = g, gen = gen_euler ,epsilon0,alpha)[1]
q=1 #Euler's method, weak convergence rate
Cbar=(2*m0)**q/(2**q-1)*(abs(Vm0e0-V2m0e0)+2*epsilon0)
Cbar #1.582089
#find m corresponding to total error less than 0.04
m=ceiling((2*Cbar/total_error)**(1/q))
m
#633
answer=MC2(g = g, gen = gen_euler, total_error / 2, alpha)
answer
#5.995319e-01 2.250000e+04
#exercise 4
#MC methpd which works for any T1:
S_euler_any=function(n,S0,m,T,r,D,sigma){
mu = r-D
dt=T/m
S=matrix(S0,nrow=m+1,ncol=n)
t=seq(0,T,length.out = m+1)
for (i in 1:m){
S[i+1,]=S[i,]*(1+mu*dt+sigma(s=S[i,])*sqrt(dt)*rnorm(n))
}
#approx value at the moment T1;
ST1 = (S[(floor((T1/T)*m) + 1),] + S[(ceiling((T1/T)*m) + 1),])/2
cbind(ST1,  S[m+1,]) #stock price at the moments T1 and T
}
gen_any = function(n){
return(S_euler_any(n,S0,m,T, r, D, sigma))
}
#test: T1 = 1/sqrt(5); m = 10, error = 0.01
T1 = 1/sqrt(5)
m = 10; error = 0.01; alpha = 0.05
ans_any = MC2(g = g, gen = gen_any, alpha = alpha, error = error)
ans_any #2.229814e-01 7.100000e+04
#test: T1 = 0.3; m = 10, error = 0.01
T1 = 0.3
m = 10; error = 0.01; alpha = 0.05
ans_any = MC2(g = g, gen = gen_any, alpha = alpha, error = error)
ans_any #5.926166e-01 2.507000e+05
#control variate method
S_euler_control=function(n,S0,m,T,mu,sigma,sigma1){
#generates pairs of stock prices for variable volatility and
# constant volatility models
#the same random number are used in both models
dt=T/m
S=matrix(S0,nrow=m+1,ncol=n)
B=0
t=seq(0,T,length.out = m+1)
for(i in 1:m){
Xi=rnorm(n,sd=sqrt(dt))
S[i+1,]=S[i,]*(1+mu*dt+sigma(S[i,])*Xi)
B=cbind(B,(B+Xi)) #current value of the Brownian motion
}
ST1 = (S[(floor((T1/T)*m) + 1),] + S[(ceiling((T1/T)*m) + 1),])/2
ST_cont=S0*exp((mu-sigma1**2/2)*T+sigma1*B)
BT1 = (B[(floor((T1/T)*m) + 1),] + B[(ceiling((T1/T)*m) + 1),])/2
ST1_cont=S0*exp((mu-sigma1**2/2)*T1+sigma1*BT1)
cbind(ST1,  S[m+1,], ST1_cont, ST_cont)
}
gen_control=function(n){
return(S_euler_control(n,S0,m,T,r-D,sigma,sigma1))
}
sigma1 = 0.5
#test
#gen_control(10)
dt=T/m
S=matrix(S0,nrow=m+1,ncol=n)
B=0
t=seq(0,T,length.out = m+1)
for(i in 1:m){
Xi=rnorm(n,sd=sqrt(dt))
S[i+1,]=S[i,]*(1+mu*dt+sigma(S[i,])*Xi)
B=cbind(B,(B+Xi)) #current value of the Brownian motion
}
n = 10
dt=T/m
S=matrix(S0,nrow=m+1,ncol=n)
B=0
t=seq(0,T,length.out = m+1)
for(i in 1:m){
Xi=rnorm(n,sd=sqrt(dt))
S[i+1,]=S[i,]*(1+mu*dt+sigma(S[i,])*Xi)
B=cbind(B,(B+Xi)) #current value of the Brownian motion
}
mu = r-D
dt=T/m
S=matrix(S0,nrow=m+1,ncol=n)
B=0
t=seq(0,T,length.out = m+1)
for(i in 1:m){
Xi=rnorm(n,sd=sqrt(dt))
S[i+1,]=S[i,]*(1+mu*dt+sigma(S[i,])*Xi)
B=cbind(B,(B+Xi)) #current value of the Brownian motion
}
B
Xi
mu = r-D
dt=T/m
S=matrix(S0,nrow=m+1,ncol=n)
B=0
t=seq(0,T,length.out = m+1)
for(i in 1:m){
Xi=rnorm(n,sd=sqrt(dt))
S[i+1,]=S[i,]*(1+mu*dt+sigma(S[i,])*Xi)
B=c(B,(B+Xi)) #current value of the Brownian motion
}
B
#control variate method
S_euler_control=function(n,S0,m,T,mu,sigma,sigma1){
#generates pairs of stock prices for variable volatility and
# constant volatility models
#the same random number are used in both models
mu = r-D
dt=T/m
S=matrix(S0,nrow=m+1,ncol=n)
B=0
t=seq(0,T,length.out = m+1)
for(i in 1:m){
Xi=rnorm(n,sd=sqrt(dt))
S[i+1,]=S[i,]*(1+mu*dt+sigma(S[i,])*Xi)
B=cbind(B,(B+Xi)) #current value of the Brownian motion
}
ST1 = (S[(floor((T1/T)*m) + 1),] + S[(ceiling((T1/T)*m) + 1),])/2
ST_cont=S0*exp((mu-sigma1**2/2)*T+sigma1*B[m+1,])
BT1 = (B[(floor((T1/T)*m) + 1),] + B[(ceiling((T1/T)*m) + 1),])/2
ST1_cont=S0*exp((mu-sigma1**2/2)*T1+sigma1*BT1)
cbind(ST1,  S[m+1,], ST1_cont, ST_cont)
}
gen_control=function(n){
return(S_euler_control(n,S0,m,T,r-D,sigma,sigma1))
}
gen_control(10)
#control variate method
S_euler_control=function(n,S0,m,T,mu,sigma,sigma1){
#generates pairs of stock prices for variable volatility and
# constant volatility models
#the same random number are used in both models
mu = r-D
dt=T/m
S=matrix(S0,nrow=m+1,ncol=n)
B=0
t=seq(0,T,length.out = m+1)
for(i in 1:m){
Xi=rnorm(n,sd=sqrt(dt))
S[i+1,]=S[i,]*(1+mu*dt+sigma(S[i,])*Xi)
B=cumsum(Xi) #current value of the Brownian motion
}
ST1 = (S[(floor((T1/T)*m) + 1),] + S[(ceiling((T1/T)*m) + 1),])/2
ST_cont=S0*exp((mu-sigma1**2/2)*T+sigma1*B[m+1,])
BT1 = (B[(floor((T1/T)*m) + 1),] + B[(ceiling((T1/T)*m) + 1),])/2
ST1_cont=S0*exp((mu-sigma1**2/2)*T1+sigma1*BT1)
cbind(ST1,  S[m+1,], ST1_cont, ST_cont)
}
gen_control=function(n){
return(S_euler_control(n,S0,m,T,r-D,sigma,sigma1))
}
gen_control(10)
#setwd("A:/MAKA/d2_13.11.2018_esimene_andmekaust_nimi_korrastamata/naidised/SMI")
setwd( "C:/Users/Mats/Documents/Kool/MAKATÖÖ/loplik_andmestik/naidised/SMI")
katvus = read.csv("Kagu-Eesti_15m_katvus.csv")
korgus = read.csv("Kagu-Eesti_15m_korgus.csv")
sat = read.csv("smi_prt_13_17_pixphv-heledused.csv")
#kõik ühe andmestikuna:
koos = read.csv("SMI_13_17_taks_ALS_SAT_koos.csv")
#sateliidi andmetes tähistavad nii 0 kui ka NA puuduvaid andmeid:
sat[sat == 0] = NA
koos[,35:230][koos[,35:230] == 0] = NA
#kasutame #koos, sest #sat pole kõiki andmeid?
satnames = names(sat); satnames = satnames[satnames != "label"]
sat = koos[,satnames]
require(tidyr)
require(stringr)
#veerunimedest vajaliku info eraldamine:
#probleem: vanema landsati nimetused teises formaadis
satnames = names(sat)
LGN = grep("LGN00", satnames) #vanemas formaadis
LGN1 = c(1:2,LGN) #"cat" ja "aproovitykk_id" ka;
sat1 = sat[,-LGN]; sat1 = subset(sat1, select = -c(prtk,muld))
sat_lgn = sat[, LGN1]
sat_long1 = sat1  %>% gather(xxx, value, -aproovitykk_id, -cat) #andmed pikas formaadis
sat_sep1 = separate(sat_long1, xxx, c("satel","ylelend","kp","band"), sep = "_") #pikas formaadis andmetest veergude eraldamine
#kuupäeva formaat:
sat_sep1$kp = as.Date(sat_sep1$kp, format="%Y%m%d")
#varem eraldatud LGN:
names_lgn = names(sat_lgn)[-c(1:2)]
#LGN formaat: LC8 - stalliit; 186019 - trajektoor; aasta; mitmes päev aastas;
n1_lgn = paste(str_sub(names_lgn,1,2),str_sub(names_lgn,4,9),str_sub(names_lgn,10,16),str_sub(names_lgn,23,24), sep = "_")
names(sat_lgn)[-c(1:2)] = n1_lgn
lgn_long = sat_lgn  %>% gather(xxx, value, -aproovitykk_id, -cat)
lgn_sep = separate(lgn_long, xxx, c("satel","ylelend","kp","band"), sep = "_")
lgn_sep$kp = as.Date(lgn_sep$kp, format="%Y%j") #kuupäeva formaat: aasta ja mitmes päev aastas
#liidame ülejäänud andmestiku juurde tagasi
sat_sep_koos = data.frame(rbind(sat_sep1, lgn_sep))
sat_sep_koos$satel[sat_sep_koos$satel  == "LC"] = "LC08" #sama satelliit
sat_sep_koos$satel[sat_sep_koos$satel  == "S2AL1C" | sat_sep_koos$satel  == "S2BL1C"] = "S2"
15*7
16**2
257 / 7
23.6**2
23.62**2
c(1:5)
dev(c(1:5))
var(c(1:5))
52.2 * 0.85 / 600
32.1 * 0.85 / 600
50000-40640
sqrt(0.00015)
sqrt(0.02)
sqrt(0.004)
sqrt(0.001)
15 sekki kalkulatsioon
20*4*15*15 / 60
50000 * 0.0245
setwd("C:/Users/Mats/Documents/Kool/MAKATÖÖ/TEST/test")
load("sid601.RData")
load("mets_id.RData")
load("lnds_to_sent.RData")
dk[,-1] = scale(dk[,-1])
muld1 = data.frame(muld = koos[koos$aproovitykk_id %in% mets_id,]$muld)
muld1$aproovitykk_id = koos$aproovitykk_id[koos$aproovitykk_id %in% mets_id]
muld1[is.na(muld1$muld),]$muld = 999
table(muld1[muld1$aproovitykk_id %in% sidxx,]$muld) #alla 10 kindlasti kokku; 2 puuduvat väärtust
muld1[muld1$muld %in% c(10,11,16,73,200,999,31,37,53,57,63), "muld"] = 999
muld2 = dcast(muld1,aproovitykk_id~muld,fun.aggregate = function(x){as.integer(length(x) > 0)})
require(dplyr)
muld2 = dcast(muld1,aproovitykk_id~muld,fun.aggregate = function(x){as.integer(length(x) > 0)})
require(reshape2)
muld2 = dcast(muld1,aproovitykk_id~muld,fun.aggregate = function(x){as.integer(length(x) > 0)})
dkm = merge(dk, muld2, by = "aproovitykk_id")
koos$cl = "cl";
koos$cl70 = "cl70";
koos$cl50 = "cl50";
koos$KX1 = koos$HB + koos$LV + koos$LM + koos$KX
require(dplyr)
koos = koos %>% mutate(weight = pmax(MA,KU, KS, KX1))
koos[!(is.na(koos$MA)) & koos$MA >= 80,]$cl = "MA"
koos[!(is.na(koos$KU)) & koos$KU >= 80,]$cl = "KU"
koos[!(is.na(koos$KS)) & koos$KS >= 80,]$cl = "KS"
koos[!(is.na(koos$KX1)) & koos$KX1 >= 80,]$cl = "KX1"
koos[!(is.na(koos$MA)) & koos$MA >= 70,]$cl70 = "MA"
koos[!(is.na(koos$KU)) & koos$KU >= 70,]$cl70 = "KU"
koos[!(is.na(koos$KS)) & koos$KS >= 70,]$cl70 = "KS"
koos[!(is.na(koos$KX1)) & koos$KX1 >= 70,]$cl70 = "KX1"
koos[!(is.na(koos$MA)) & koos$MA > 50,]$cl50 = "MA"
koos[!(is.na(koos$KU)) & koos$KU > 50,]$cl50 = "KU"
koos[!(is.na(koos$KS)) & koos$KS > 50,]$cl50 = "KS"
koos[!(is.na(koos$KX1)) & koos$KX1 > 50,]$cl50 = "KX1"
dkm0 = merge(dkm,koos[,c("aproovitykk_id", "cl", "weight", "muld")], all.x = T)
dkm70 = merge(dkm,koos[,c("aproovitykk_id", "cl70", "weight", "muld")], all.x = T)
dkm50 = merge(dkm,koos[,c("aproovitykk_id", "cl50", "weight", "muld")], all.x = T)
dkm0 = dkm0[dkm0$aproovitykk_id %in% sidxx,]
dkm70 = dkm70[dkm70$aproovitykk_id %in% sidxx,]
dkm50 = dkm50[dkm50$aproovitykk_id %in% sidxx,]
table(dkm0$cl)     #52  37  36 138    kui 80%
table(dkm70$cl70) #85   51   43  163 kui 70%
table(dkm50$cl50) #136   89   67  224
dp00 = taks_uus[, puud]; dp00 = dp00 / rowSums(dp00)
puud
ddd = read.csv("d601.csv")
dkm1 = dkm0 %>% filter(cl != "cl")
dkm50_ = dkm50 %>% filter(cl50 != "cl50")
dkm70_ = dkm70 %>% filter(cl70 != "cl70")
View(ddd)
table(dkm1$cl)
dkm1[dkm1$muld %in% names(table(dkm1$muld) < 10)[table(dkm1$muld) < 10],"muld"] = 999
dkm1[is.na(dkm1$muld),"muld"] = 999
dkm0[!(dkm0$muld %in% names(table(dkm1$muld) < 10)[table(dkm1$muld) >= 10]),"muld"] = 999
dkm0[is.na(dkm0$muld),"muld"] = 999
table(dkm0$muld)
dkm50_[dkm50_$muld %in% names(table(dkm50_$muld) < 10)[table(dkm50_$muld) < 10],"muld"] = 999
dkm50_[is.na(dkm50_$muld),"muld"] = 999
dkm70_[dkm70_$muld %in% names(table(dkm70_$muld) < 10)[table(dkm70_$muld) < 10],"muld"] = 999
dkm70_[is.na(dkm70_$muld),"muld"] = 999
nms = names(dkm50_); nms[49] = "cl"; names(dkm50_) = nms
nms = names(dkm70_); nms[49] = "cl"; names(dkm70_) = nms
require(nnet)
namesz = names(dkm1)[c(2:37,51)]
namesz[37] = "factor(muld)"
formula1 = as.formula(paste("cl", paste(namesz, collapse=" + "), sep=" ~ "))
m1 = multinom(formula1, dkm50_, weights = weight)
m1
summary(m1)
Anova(m1)
?Anova
??Anova
require(car);require(lmtest); require(MASS)
Anova(m1)
require(MASS)
Anova(m1)
require(car);
install.packages("car")
install.packages(car)
install.packages("car")
require(lmtest);
install.packages("lmtest")
require(lmtest);
install.packages("lmtest")
install.packages("lmtest")
install.packages("lmtest")
require(lmtest);
install.packages("car")
p1 = predict(m2, dkm50_, type = "probs")
m2 = stepAIC(multinom(formula1, dkm50_)) #, weights = weight
summary(m2)
require(MASS)
Anova(m2)
require(lmtest)
require(car)
require(nnet)
namesz = names(dkm1)[c(2:37,51)]
namesz[37] = "factor(muld)"
formula1 = as.formula(paste("cl", paste(namesz, collapse=" + "), sep=" ~ "))
m1 = multinom(formula1, dkm50_, weights = weight)
m1
m1
summary(m1)
namesz = names(dkm1)[c(2:37,51)]
namesz[37] = "factor(muld)"
namesz = namesz[-37]
formula1 = as.formula(paste("cl", paste(namesz, collapse=" + "), sep=" ~ "))
m1 = step(multinom(formula1, dkm50_, weights = weight))
m1
summary(m1)
m1 = step(multinom(formula1, dkm50_, weights = weight))
m1
?step
?step
m1 = step(multinom(formula1, dkm50_, weights = weight,maxit = 1000))
m1
